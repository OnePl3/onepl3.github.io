[{"categories":["PAT Basic"],"content":"PAT Basic 1004. 成绩排名（20分） (C语言实现) ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:0","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"题目 读入 n（\u003e0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:1","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"输入格式 第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 … … … 第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:2","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"输出格式 对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:3","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"输入样例 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:4","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"输出样例 Mike CS991301 Joe Math990112 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:5","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"思路 相比于1003,1004是一道相对简单的题 我们可以使用数据结构中找Max or Min的思想,如果满足条件,不断交换至找到最值 注意题目所给三种数据的范围 ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:6","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"实现代码 #include\u003cstdio.h\u003e#include\u003cstring.h\u003e int main(){ int N; scanf(\"%d\",\u0026N); //Max—最大值的各种数据项 //Min-最小值的各种数据项 //cur-当前值的各种数据项 char maxname[11],minname[11],curname[11], maxid[11],minid[11],curid[11]; int max = -1, min = 101, cur; for(int i = 0;i \u003c N; i++){ scanf(\"%s %s %d\",curname,curid,\u0026cur); //cur-字符串不给赋值符号\u0026 if(cur \u003e max){ strcpy(maxname,curname); strcpy(maxid,curid); max=cur; } if(cur \u003c min){ strcpy(minname,curname); strcpy(minid,curid); min=cur; } } printf(\"%s %s\\n\",maxname,maxid); printf(\"%s %s\",minname,minid); return 0; } ","date":"2021-01-10","objectID":"/posts/pat-basic-1004/:0:7","tags":["PAT Basic","C"],"title":"PAT Basic 1004","uri":"/posts/pat-basic-1004/"},{"categories":["PAT Basic"],"content":"PAT Basic 1003. 我要通过（20分） (C语言实现) ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:0","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"题目 “答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:1","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"输入格式 每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (\u003c10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:2","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"输出格式 每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:3","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"输入样例 8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:4","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"输出样例 YES YES YES YES NO NO NO NO ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:5","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"思路 审题 字符串只能包含‘P’ ‘A ’ ‘T’三种字符,如果存在其他字符则判错 xPATx格式是正确的,这个条件需要正确理解,两个x是指代相同的字符串!!! aPbTc正确,aPbATca也正确.本题的重点! P和T中间每增加一个A,就需要将P之前的内容复制到字符串尾部. 总结 注意看这八个测试样例 只存在‘P’ ‘ T’ ‘A’ 这三个字符 ‘P’ 与 ‘T’ 的先后关系 ‘P’ 与 ‘T’ 之间不能没有 ‘A’ ‘T’ 之后 ‘A’ 的数量 = ‘P’ 之前 ‘A’ 的数量 $*$ ‘P\u0026T’ 中间 ‘A’ 的数量 代码思路 用三个数分别记录三个位置的‘A’个数（用数组count 使用类似标记变量pos,检查‘P’,‘T’的出现及次序 (count[pos]) 其值在出现P之前为0（使用count[0]记录P之前的A） 只有在出现P且其值为0时，将值变为1（使用count[1]记录P\u0026T之间的A） 只有在出现T且其值为1时，将其变为2（使用count[2]记录T之后的A） ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:6","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"实现代码 #include \u003cstdio.h\u003e int main() { char c; int num; scanf(\"%d\", \u0026num); while(getchar() != '\\n'); /* 确保从读取每行时,从开头读取：‘\\n’分割 */ for(int i = 0; i \u003c num; i++) { int pos = 0, count[3] = {0, 0, 0}; while((c = getchar()) != '\\n') { if(c == 'A') count[pos]++; /* count 'A's */ else if(c == 'P' \u0026\u0026 pos == 0) pos = 1; /* one P before T */ else if(c == 'T' \u0026\u0026 pos == 1) pos = 2; /* one T after P */ else break; /* 'wrong' string */ } if(c == '\\n' \u0026\u0026 pos == 2 \u0026\u0026 count[1] \u0026\u0026 count[2] == count[1] * count[0]) //见思路 puts(\"YES\"); else puts(\"NO\"); /* read the rest of the line */ if(c != '\\n') while(getchar() != '\\n'); } return 0; } ","date":"2021-01-10","objectID":"/posts/pat-basic-1003/:0:7","tags":["PAT Basic","C"],"title":"PAT Basic 1003","uri":"/posts/pat-basic-1003/"},{"categories":["PAT Basic"],"content":"PAT Basic 1002. 写出这个数（20分） (C语言实现) ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:0","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"题目 读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:1","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"输入格式 每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 ${10}^{100}$ ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:2","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"输出格式 在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:3","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"输入样例 1234567890987654321123456789 ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:4","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"输出样例 yi san wu ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:5","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"思路 读取每一位上的数值,本是相对比较简单的操作(见注释) 但我们发现输入样例过长时,继续将输入值用int做,将无法通过测试. 故我们将输入值转换为字符串进行操作 ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:6","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"实现代码 #include \u003cstdio.h\u003e/* while(num){ i=num%10; s+=i; num/=10; printf(\"%d %d\\n\",i,num); } */ int main() { int sum = 0; char c, *number[] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"}; //提前存入数字对应对拼音 while((c = getchar()) != '\\n') sum += c - '0'; //遍历字符串每一个字符,并且利用ascii码将字符转为数字后累加至sum if(sum / 100) /* hundreds */ printf(\"%s \", number[sum / 100]); if(sum / 10) /* tens */ printf(\"%s \", number[sum / 10 % 10]); printf(\"%s\", number[sum % 10]); /* units */ return 0; } ","date":"2021-01-10","objectID":"/posts/pat-basic-1002/:0:7","tags":["PAT Basic","C"],"title":"PAT Basic 1002","uri":"/posts/pat-basic-1002/"},{"categories":["PAT Basic"],"content":"PAT Basic 1001. 害死人不偿命的(3n+1)猜想 (15) (C语言实现) ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:0","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"题目 卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:1","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"输入格式 每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:2","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"输出格式 输出从 n 计算到 1 需要的步数。 ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:3","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"输入样例 3 ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:4","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"输出样例 5 ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:5","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"思路 较为简单的一道题,按照规则读取输入数值后,对其循环处理直至number=1. ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:6","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":["PAT Basic"],"content":"实现代码 #include \u003cstdio.h\u003e int main() { int number, steps; scanf(\"%d\", \u0026number); for(steps = 0; number != 1; steps++) if(number % 2 == 0) number /= 2; else number = (3 * number + 1) / 2; printf(\"%d\", steps); return 0; } ","date":"2021-01-09","objectID":"/posts/pat-basic-1001/:0:7","tags":["PAT Basic","C"],"title":"PAT Basic 1001","uri":"/posts/pat-basic-1001/"},{"categories":null,"content":"Hello Hugo! ","date":"2021-01-07","objectID":"/posts/first/:0:0","tags":null,"title":"First","uri":"/posts/first/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About LoveIt","uri":"/about/"}]