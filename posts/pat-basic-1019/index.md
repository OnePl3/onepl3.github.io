# PAT Basic 1019


# PAT Basic 1019. 数字黑洞（20分）

 (C语言实现)
<!--more-->

### 题目

给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。

​	例如，我们从`6767`开始，将得到

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
```

现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。



### 输入格式

输入给出一个 (0,$$ 10^4 $$) 区间内的正整数 *N*。



### 输出格式

如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。



### 输入样例1

```
6767
```

### 输出样例1

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
```

### 输入样例2

```
2222
```

### 输出样例2

```
2222 - 2222 = 0000
```



### 思路

- 输入值是一个4位数,我们需要先将输入值各位排序,并转置排序后的值
- 回顾PAT Basic 1015中用到的qsort函数,那边文章中有详细的qsort使用说明
- 让我们把问题简单化,细分每个关键功能,再进行组装
- do-while的用法相对简单,浅显易懂

### 实现代码

```c
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b){
    return *(int*)b - *(int*)a;
}

int sort(int n){/* 输出排序完后的4位数数值 */
    int digits[4] = {n/1000, n%1000/100, n%100/10, n%10};/* 记录每一位 */
    qsort(digits, 4, sizeof(int), cmp);/* 排序 */
    return digits[0] * 1000 + digits[1] * 100 + digits[2] * 10 + digits[3];
}

int reverse(int n){/* 4位数的转置,统计各位 */
    return n/1000 + n%1000/100 * 10 + n%100/10 * 100 + n%10 * 1000;
}

int main(){
    int N;

    scanf("%d", &N);
    do{
        N = sort(N);
        printf("%04d - %04d = %04d\n", N, reverse(N), N - reverse(N));
      /* %04d控制输出位数:1会显示为0001 */
        N = N - reverse(N);
    }while(N != 0 && N != 6174) ;

    return 0;
}
```


