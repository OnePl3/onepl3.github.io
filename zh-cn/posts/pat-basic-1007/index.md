# PAT Basic 1007


# PAT Basic 1007. 素数对猜想（20分）

 (C语言实现)
<!--more-->

### 题目

让我们定义$$ d_n $$为 ：$$ d_n = P_{n+1} - P_n $$，其中$$ P_i $$是第i个素数。显然有$$ d_1 = 1 $$，且对于*n*>1有$$ d_n $$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。

现给定任意正整数`N`(<$$ 10^5 $$)，请计算不超过`N`的满足猜想的素数对的个数。



### 输入格式

输入在一行给出正整数`N`。



### 输出格式

在一行中输出不超过`N`的满足猜想的素数对的个数。



### 输入样例

```
20
```

### 输出样例

```
4
```



### 思路

##### 分析题目

- 素数！只能被自身和一整除
- 且对于*n*>1有$$ d_n $$是偶数！素数只可能是奇数
- 输入的是不超过N的猜想,不是N的猜想！
- 1-20 试着写出所有素数 （1,2,3,5,7,11,13,17,19)

##### 实现思路

- 初始化：100个素数里初始化便写入第1个位置,标记为a[1]=1,从2开始验证，这样不影响边界情况（N=5之前没有孪生素数），避免了2这样**没有更小的素数**可供验证的情况，并且进入循环即可开始验证孪生素数

##### 结果参考

|   N    | 孪生素数对数 |
| :----: | :----------: |
|  1-4   |      0       |
|   20   |      4       |
|  100   |      8       |
|  1000  |      35      |
| 10000  |     205      |
| 100000 |     1224     |



### 实现代码

```c
#include<stdio.h>

int main()
{
  int a[100000] = {0};
  int n, t = 1, c = 0;
  scanf("%d",&n);
  a[1] = 1;
  for(int i = 2;i <= n; i++)
  {
    if(!a[i])//a[i] = 0执行
    {
      if(i - t == 2) c++;//判断是否满足素数对
      t = i;//交换
      for(int j = 2;j * i <= n; j++) a[i * j]=1;
      //当前相邻不满足素数对,将所有非素数位置标价
    }
  }
  printf("%d",c);
  return 0;
}
```


